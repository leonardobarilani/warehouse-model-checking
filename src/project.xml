<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Global system parameters
const int N_BOTS            = 3;
const int N_POD_ROWS        = 3;
const int N_PODS_PER_ROW    = 5;
const int QUEUE_CAPACITY    = 5;
const int TASK_GEN_MEAN     = 20;
const int TASK_GEN_VAR      = 5;
const int HUMAN_MEAN        = 2;
const int HUMAN_VAR         = 1;
const int BOT_IDLE_EXP_RATE = 3;
const int BOT_STEP_TIME     = 1;
const int TAU               = 1000;

// Global *derived* system parameters
const int QUEUE_SIZE = QUEUE_CAPACITY + 1;
const int N_PODS     = N_POD_ROWS * N_PODS_PER_ROW;
const int MAP_H      = N_POD_ROWS * 2 + 1;
const int MAP_W      = N_PODS_PER_ROW + 3;

// Global types
typedef int[0, N_BOTS - 1] bot_t;
typedef int[0, N_PODS - 1] pod_t;
typedef struct { int r, c; } pos_t;

// Global constants
const pos_t ENTRY_POS = { 0, 1 };
const pos_t HUMAN_POS = { 0, 0 };
const int POD_FREE    = 0;
const int POD_BUSY    = 1;
const int NONE        = -1;
const int N           =  1; // North
const int S           =  2; // South
const int E           =  4; // East
const int W           =  8; // West
const int X           = 16; // Crossing
const int B           = 32; // Bot present
const int P           = 64; // Pod present

// Global counters
int tasks_lost = 0;      // n. of tasks lost because the queue was full
int tasks_completed = 0; // n. of tasks succesfully completed (pickup + delivery + return)

// All defined channels
urgent broadcast chan asap;           // dummy urgent channel to complete actions as soon as possible
urgent broadcast chan step;           // synchronize bot movements to help bots stuck in line to move as soon as possible
urgent broadcast chan init_done;      // signal everyone that global vars are initialized
urgent broadcast chan human_done;     // notify currently delivering bot that human finished their job
urgent broadcast chan delivery_ready; // notify human that bot just arrived to deliver a pod

// Global variables
int map[MAP_H][MAP_W];      // warehouse map
int pods[N_PODS];           // status of pods: each pod can either be FREE or BUSY
int free_pods = N_PODS;     // n. of currently free pods (not assigned as a task to any bot)
pos_t pod_position[N_PODS]; // positions of pods (coords), only generated once during initialization
int queue[QUEUE_SIZE];      // task FIFO queue (implemented as a ring buffer)
int queue_head = 0;
int queue_tail = 0;

/*************** Global utility functions *****************/

/*
 * Add one task to the queue. If the queue is full, the task gets lost and the
 * global counter tasks_lost is incremented.
 */
void enqueue(int free_pod_id) {
    if ((queue_head + 1) % QUEUE_SIZE == queue_tail) {
        // Queue is full
        tasks_lost++;
        return;
    }

    queue[queue_head] = free_pod_id;
    queue_head = (queue_head + 1) % QUEUE_SIZE;
    pods[free_pod_id] = POD_BUSY;
    free_pods--;
}

/*
 * Pop and return a task from the queue, assuming it is not empty.
 */
int dequeue() {
    int el = queue[queue_tail];
    queue[queue_tail] = NONE;
    queue_tail = (queue_tail + 1) % QUEUE_SIZE;
    return el;
}

/*
 * Check whether the queue is empty.
 */
bool queue_empty() {
    return queue_head == queue_tail;
}

/*
 * Get the value of a cell of the map given its pos_t coordinates.
 */
int cell(pos_t p) {
    return map[p.r][p.c];
}

/*
 * Check whether a cell of the map is occupied by a bot or not.
 */
bool cell_is_free(pos_t p) {
    return !(cell(p) &amp; B);
}</declaration>
	<template>
		<name x="5" y="5">TaskGenerator</name>
		<parameter>const int mean, const int variance</parameter>
		<declaration>const int u_min = (mean - variance) / 3;
const int u_max = (mean + variance) / 3;
clock x;</declaration>
		<location id="id0" x="-306" y="-136">
			<label kind="invariant" x="-323" y="-170">x &lt;= u_max</label>
		</location>
		<location id="id1" x="-153" y="-136">
			<label kind="invariant" x="-170" y="-170">x &lt;= u_max</label>
		</location>
		<location id="id2" x="144" y="-136">
		</location>
		<location id="id3" x="-425" y="-136">
		</location>
		<location id="id4" x="4" y="-136">
			<label kind="invariant" x="-13" y="-170">x &lt;= u_max</label>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-408" y="-161">init_done?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="select" x="-289" y="-93">pod_id: pod_t</label>
			<label kind="guard" x="-289" y="-76">pods[pod_id] == POD_FREE &amp;&amp; cell_is_free(pod_position[pod_id])</label>
			<label kind="synchronisation" x="-289" y="-59">asap!</label>
			<label kind="assignment" x="-289" y="-42">enqueue(pod_id), x = 0</label>
			<nail x="144" y="-102"/>
			<nail x="-25" y="-102"/>
			<nail x="-306" y="-102"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-136" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="-136" y="-136">x = 0</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-289" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="-289" y="-136">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="21" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="21" y="-136">x = 0</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>const int mean, const int variance</parameter>
		<declaration>const int u_min = (mean - variance) / 3;
const int u_max = (mean + variance) / 3;
clock x;</declaration>
		<location id="id5" x="-85" y="-76">
		</location>
		<location id="id6" x="161" y="-76">
			<label kind="invariant" x="170" y="-102">x &lt;= u_max</label>
		</location>
		<location id="id7" x="340" y="-76">
			<label kind="invariant" x="357" y="-102">x &lt;= u_max</label>
		</location>
		<location id="id8" x="17" y="-76">
		</location>
		<location id="id9" x="688" y="-76">
		</location>
		<location id="id10" x="527" y="-76">
			<label kind="invariant" x="544" y="-102">x &lt;= u_max</label>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="578" y="-51">human_done!</label>
			<nail x="688" y="-25"/>
			<nail x="17" y="-25"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id10"/>
			<label kind="guard" x="357" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="356" y="-119">x = 0</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="170" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="170" y="-119">x = 0</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="34" y="-110">delivery_ready?</label>
			<label kind="assignment" x="34" y="-93">x = 0</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-68" y="-102">init_done?</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="guard" x="544" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="543" y="-119">x = 0</label>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<declaration>void initialize_all() {
    int i, r, c;
    int cur_pod_id = 0;

    for (i = 0; i &lt; N_PODS; i++)
        pods[i] = POD_FREE;

    for (i = 0; i &lt; QUEUE_SIZE; i++)
        queue[i] = NONE;

    for (r = 0; r &lt; MAP_H; r++)
        for (c = 0; c &lt; MAP_W; c++)
            map[r][c] = 0;

    // Top row
    for (c = 0; c &lt; MAP_W - 1; c++)
        map[0][c] = E;

    // Rightmost column
    for (r = 0; r &lt; MAP_H - 1; r++)
        map[r][MAP_W - 1] = S;

    // Leftmost and second-leftmost column
    for (r = 1; r &lt; MAP_H; r++) {
        map[r][0] = N;
        map[r][1] = N;
    }

    // Pod rows
    for (r = 1; r &lt; MAP_H; r += 2) {
        for (c = 2; c &lt; MAP_W - 1; c++) {
            pod_position[cur_pod_id].r = r;
            pod_position[cur_pod_id].c = c;
            cur_pod_id++;
            map[r    ][c] = P | S;
            map[r + 1][c] = W;
        }

        map[r + 1][1] = X;
        map[r + 1][MAP_W - 1] = X;
    }

    // Bottom right
    map[MAP_H - 1][MAP_W - 1] = W;
}</declaration>
		<location id="id11" x="-68" y="-8">
			<committed/>
		</location>
		<location id="id12" x="68" y="-8">
		</location>
		<init ref="id11"/>
		<transition>
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-51" y="-42">init_done!</label>
			<label kind="assignment" x="-51" y="-25">initialize_all()</label>
		</transition>
	</template>
	<template>
		<name>Bot</name>
		<parameter>const bot_t id</parameter>
		<declaration>const int OBJ_HUMAN  = 1;
const int OBJ_PICKUP = 2;
const int OBJ_RETURN = 3;

clock x;
pos_t pos           = {-1, -1};
pos_t objective_pos = {-1, -1};
pod_t pod_id        = 0;
int   objective     = -1;
bool  did_step      = false;

void update_objective(const int obj) {
    objective = obj;

    if (objective == OBJ_HUMAN)
        objective_pos = HUMAN_POS;
    else
        objective_pos = pod_position[pod_id];
}

void enter() {
    pos = ENTRY_POS;
    map[pos.r][pos.c] |= B;
}

void get_task() {
    pod_id = dequeue();
    pods[pod_id] = POD_BUSY;
    update_objective(OBJ_PICKUP);
}

void complete_task() {
    pods[pod_id] = POD_FREE;
    pod_id = 0;
    objective_pos.r = -1;
    objective_pos.c = -1;
    tasks_completed++;
}

// Update given position one step in the only possible direction
void follow_path(int cell, pos_t &amp;p) {
    if (cell &amp; N) p.r--;
    else if (cell &amp; S) p.r++;
    else if (cell &amp; E) p.c++;
    else if (cell &amp; W) p.c--;
}

// Try to step if possible, set did_step accordingly
void maybe_step() {
    pos_t newpos = pos;
    int c = cell(pos);

    did_step = false;

    if (objective == OBJ_HUMAN) {
        if (c &amp; X) {
            // We are at a cross, go W
            newpos.c--;
        } else {
            // Otherwise just follow the only possible dir
            follow_path(c, newpos);
        }
    } else {
        if (pos.c == objective_pos.c &amp;&amp; pos.r == objective_pos.r + 1) {
            // We are in the cell immediately S of the pod, go N
            newpos.r--;
        } else if (c &amp; X) {
            // We are at a cross
            if (pos.c == 1) {
                // We are on the west-side highway, go up
                newpos.r--;
            } else if (pos.r == objective_pos.r + 1) {
                // We reached the pod row, go W
                newpos.c--;
            } else {
                // Otherwise go S
                newpos.r++;
            }
        } else {
            // Otherwise just follow the only possible dir
            follow_path(c, newpos);
        }
    }

    // Now try to step in the needed cell i.e. at newpos

    if (cell_is_free(newpos)) {
        // At map entry we have pos == newpos, avoid this edge case
        if (pos != newpos)
            map[pos.r][pos.c] -= B;

        map[newpos.r][newpos.c] |= B;
        pos = newpos;
        did_step = true;
    }
}</declaration>
		<location id="id13" x="-612" y="-25">
		</location>
		<location id="id14" x="-510" y="-25">
			<name x="-561" y="-8">WAIT_FIRST_TASK</name>
		</location>
		<location id="id15" x="-144" y="-25">
			<name x="-195" y="-59">STEP_TO_OBJECTIVE</name>
			<label kind="invariant" x="-195" y="-76">x &lt;= BOT_STEP_TIME</label>
		</location>
		<location id="id16" x="-144" y="59">
		</location>
		<location id="id17" x="-144" y="153">
			<committed/>
		</location>
		<location id="id18" x="-382" y="187">
			<name x="-425" y="197">WAIT_HUMAN</name>
		</location>
		<location id="id19" x="-382" y="332">
			<name x="-399" y="306">IDLE</name>
			<label kind="exponentialrate" x="-442" y="349">BOT_IDLE_EXP_RATE</label>
		</location>
		<location id="id20" x="-348" y="-25">
			<committed/>
		</location>
		<init ref="id13"/>
		<transition>
			<source ref="id20"/>
			<target ref="id15"/>
			<label kind="assignment" x="-289" y="-42">x = 0</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id19"/>
			<label kind="guard" x="-348" y="297">objective == OBJ_RETURN</label>
			<label kind="assignment" x="-348" y="314">complete_task()</label>
			<nail x="-144" y="332"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id20"/>
			<label kind="guard" x="-467" y="230">objective == OBJ_PICKUP</label>
			<label kind="assignment" x="-467" y="247">update_objective(OBJ_HUMAN)</label>
			<nail x="-144" y="264"/>
			<nail x="-620" y="264"/>
			<nail x="-620" y="246"/>
			<nail x="-620" y="238"/>
			<nail x="-620" y="229"/>
			<nail x="-620" y="110"/>
			<nail x="-348" y="110"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id20"/>
			<label kind="synchronisation" x="-612" y="153">human_done?</label>
			<label kind="assignment" x="-612" y="171">update_objective(OBJ_RETURN)</label>
			<nail x="-620" y="188"/>
			<nail x="-620" y="110"/>
			<nail x="-501" y="110"/>
			<nail x="-348" y="110"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="guard" x="-119" y="0">x &gt;= BOT_STEP_TIME</label>
			<label kind="assignment" x="-119" y="16">maybe_step(), x = 0</label>
			<nail x="-127" y="-8"/>
			<nail x="-127" y="34"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-314" y="-8">did_step &amp;&amp;
pos != objective_pos</label>
			<label kind="synchronisation" x="-204" y="25">step!</label>
			<label kind="assignment" x="-204" y="42">x = 0</label>
			<nail x="-161" y="34"/>
			<nail x="-161" y="0"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id18"/>
			<label kind="guard" x="-348" y="153">objective == OBJ_HUMAN</label>
			<label kind="synchronisation" x="-348" y="170">delivery_ready!</label>
			<nail x="-144" y="188"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id17"/>
			<label kind="guard" x="-306" y="76">did_step &amp;&amp;
pos == objective_pos</label>
			<label kind="synchronisation" x="-195" y="110">step!</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id16"/>
			<label kind="guard" x="-76" y="51">!did_step</label>
			<label kind="synchronisation" x="-76" y="68">step?</label>
			<label kind="assignment" x="-76" y="85">maybe_step()</label>
			<nail x="-85" y="93"/>
			<nail x="-85" y="59"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id20"/>
			<label kind="guard" x="-493" y="-110">!queue_empty()
&amp;&amp; cell_is_free(ENTRY_POS)</label>
			<label kind="synchronisation" x="-493" y="-76">asap!</label>
			<label kind="assignment" x="-493" y="-59">enter(),
get_task()</label>
			<nail x="-374" y="-25"/>
			<nail x="-374" y="-25"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-595" y="-50">init_done?</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="guard" x="-612" y="280">!queue_empty()</label>
			<label kind="synchronisation" x="-612" y="297">asap!</label>
			<label kind="assignment" x="-612" y="314">get_task()</label>
			<nail x="-620" y="331"/>
			<nail x="-620" y="110"/>
			<nail x="-501" y="110"/>
			<nail x="-348" y="110"/>
		</transition>
	</template>
	<system>initializer = Initializer();
generator   = TaskGenerator(TASK_GEN_MEAN, TASK_GEN_VAR);
human       = Human(HUMAN_MEAN, HUMAN_VAR);

system initializer, generator, human, Bot;
</system>
	<queries>
		<query>
			<formula>E&lt;&gt; tasks_lost &gt; 0</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr [&lt;=100000] ( &lt;&gt; tasks_lost != 0 )</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
