<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>// Global parameters
const int N_BOTS            = 3;
const int N_POD_ROWS        = 5;
const int N_PODS_PER_ROW    = 5;
const int QUEUE_CAPACITY    = 5;
const int TASK_GEN_MEAN     = 20;
const int TASK_GEN_VAR      = 5;
const int HUMAN_MEAN        = 2;
const int HUMAN_VAR         = 1;
const int BOT_IDLE_EXP_RATE = 3;
const int BOT_STEP_TIME     = 1;
const int TAU               = 1000;

// Global constants
const int QUEUE_SIZE = QUEUE_CAPACITY + 1;
const int N_PODS     = N_POD_ROWS * N_PODS_PER_ROW;
const int MAP_H      = N_POD_ROWS * 2 + 1;
const int MAP_W      = N_PODS_PER_ROW + 3;

// Global types
typedef int[0, N_BOTS - 1] bot_t;
typedef int[0, N_PODS - 1] pod_t;
typedef struct { int r, c; } pos_t;

// Global special values
const pos_t ENTRY_POS = { 0, 1 };
const pos_t HUMAN_POS = { 0, 0 };
const int POD_FREE = 0;
const int POD_BUSY = 1;
const int NONE = -1;
const int N =  1; // North
const int S =  2; // South
const int E =  4; // East
const int W =  8; // West
const int X = 16; // Crossing
const int B = 32; // Bot present
const int P = 64; // Pod present

// Global counters
int tasks_lost = 0;      // n. of tasks lost because the queue was full
int tasks_completed = 0; // n. of tasks succesfully completed (pickup + delivery + return)

int map[MAP_H][MAP_W];

urgent broadcast chan asap;           // dummy urgent channel to complete actions as soon as possible
urgent broadcast chan init_done;      // signal everyone that global vars are initialized
urgent broadcast chan human_done;     // notify currently delivering bot that human finished their job
urgent broadcast chan delivery_ready; // notify human that bot just arrived to deliver a pod

// Status of pods: each pod can either be FREE or BUSY
int pods[N_PODS];
int free_pods = N_PODS; // n. of currently free pods
// Positions of pods (coords), only generated once during initialization
pos_t pod_position[N_PODS];

// Task queue (implemented as a ring buffer)
int queue[QUEUE_SIZE];
int queue_head = 0;
int queue_tail = 0;

/*************** Global utility functions *****************/

// Add one task to the queue, if full the task gets lost
void enqueue(int free_pod_id) {
    if ((queue_head + 1) % QUEUE_SIZE == queue_tail) {
        // Queue is full
        tasks_lost++;
        return;
    }

    queue[queue_head] = free_pod_id;
    queue_head = (queue_head + 1) % QUEUE_SIZE;
    pods[free_pod_id] = POD_BUSY;
    free_pods--;
}

// Pop one task from the queue, assuming it is not empty
int dequeue() {
    int el = queue[queue_tail];
    queue[queue_tail] = NONE;
    queue_tail = (queue_tail + 1) % QUEUE_SIZE;
    return el;
}

int queue_empty() {
    return queue_head == queue_tail;
}

int cell(pos_t p) {
    return map[p.r][p.c];
}

int cell_is_free(pos_t p) {
    return !(cell(p) &amp; B);
}</declaration>
	<template>
		<name x="5" y="5">TaskGenerator</name>
		<parameter>const int mean, const int variance, const int n_pods</parameter>
		<declaration>const int u_min = (mean - variance) / 3;
const int u_max = (mean + variance) / 3;
clock x;</declaration>
		<location id="id0" x="-306" y="-136">
			<label kind="invariant" x="-323" y="-170">x &lt;= u_max</label>
		</location>
		<location id="id1" x="-153" y="-136">
			<label kind="invariant" x="-170" y="-170">x &lt;= u_max</label>
		</location>
		<location id="id2" x="144" y="-136">
		</location>
		<location id="id3" x="-425" y="-136">
		</location>
		<location id="id4" x="4" y="-136">
			<label kind="invariant" x="-13" y="-170">x &lt;= u_max</label>
		</location>
		<init ref="id3"/>
		<transition>
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-408" y="-161">init_done?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id0"/>
			<label kind="select" x="-289" y="-93">pod_id: pod_t</label>
			<label kind="guard" x="-289" y="-76">pods[pod_id] == POD_FREE
&amp;&amp; cell_is_free(pod_position[pod_id])</label>
			<label kind="synchronisation" x="-289" y="-42">asap!</label>
			<label kind="assignment" x="-289" y="-25">enqueue(pod_id), x = 0</label>
			<nail x="144" y="-102"/>
			<nail x="-25" y="-102"/>
			<nail x="-306" y="-102"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-136" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="-136" y="-136">x = 0</label>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="guard" x="-289" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="-289" y="-136">x = 0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="21" y="-153">x &gt;= u_min</label>
			<label kind="assignment" x="21" y="-136">x = 0</label>
		</transition>
	</template>
	<template>
		<name>Human</name>
		<parameter>const int mean, const int variance</parameter>
		<declaration>const int u_min = (mean - variance) / 3;
const int u_max = (mean + variance) / 3;
clock x;</declaration>
		<location id="id5" x="-85" y="-76">
		</location>
		<location id="id6" x="161" y="-76">
			<label kind="invariant" x="170" y="-102">x &lt;= u_max</label>
		</location>
		<location id="id7" x="340" y="-76">
			<label kind="invariant" x="357" y="-102">x &lt;= u_max</label>
		</location>
		<location id="id8" x="17" y="-76">
		</location>
		<location id="id9" x="688" y="-76">
		</location>
		<location id="id10" x="527" y="-76">
			<label kind="invariant" x="544" y="-102">x &lt;= u_max</label>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="578" y="-51">human_done!</label>
			<nail x="688" y="-25"/>
			<nail x="17" y="-25"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id10"/>
			<label kind="guard" x="357" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="356" y="-119">x = 0</label>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id7"/>
			<label kind="guard" x="170" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="170" y="-119">x = 0</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="42" y="-110">delivery_ready?</label>
			<label kind="assignment" x="68" y="-93">x = 0</label>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id8"/>
			<label kind="synchronisation" x="-68" y="-102">init_done?</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="guard" x="544" y="-136">x &gt;= u_min</label>
			<label kind="assignment" x="543" y="-119">x = 0</label>
		</transition>
	</template>
	<template>
		<name>Initializer</name>
		<declaration>void initialize_all() {
    int i, r, c;
    int cur_pod_id = 0;

    for (i = 0; i &lt; N_PODS; i++)
        pods[i] = POD_FREE;

    for (i = 0; i &lt; QUEUE_SIZE; i++)
        queue[i] = NONE;

    for (r = 0; r &lt; MAP_H; r++)
        for (c = 0; c &lt; MAP_W; c++)
            map[r][c] = 0;

    // Top row
    for (c = 0; c &lt; MAP_W - 1; c++)
        map[0][c] = E;

    // Rightmost column
    for (r = 0; r &lt; MAP_H - 1; r++)
        map[r][MAP_W - 1] = S;

    // Leftmost and second-leftmost column
    for (r = 1; r &lt; MAP_H; r++) {
        map[r][0] = N;
        map[r][1] = N;
    }

    // Pod rows
    for (r = 1; r &lt; MAP_H; r += 2) {
        for (c = 2; c &lt; MAP_W - 1; c++) {
            pod_position[cur_pod_id].r = r;
            pod_position[cur_pod_id].c = c;
            cur_pod_id++;
            map[r    ][c] = P | S;
            map[r + 1][c] = W;
        }

        map[r + 1][1] = X;
        map[r + 1][MAP_W - 1] = X;
    }

    // Bottom right
    map[MAP_H - 1][MAP_W - 1] = W;
}</declaration>
		<location id="id11" x="-51" y="-8">
			<committed/>
		</location>
		<location id="id12" x="68" y="-8">
		</location>
		<init ref="id11"/>
		<transition>
			<source ref="id11"/>
			<target ref="id12"/>
			<label kind="synchronisation" x="-33" y="-25">init_done!</label>
			<label kind="assignment" x="-33" y="-8">initialize_all()</label>
		</transition>
	</template>
	<template>
		<name>Bot</name>
		<parameter>const bot_t id</parameter>
		<declaration>const int K = BOT_STEP_TIME;
clock x;

pos_t pos = ENTRY_POS;
pod_t target_pod_id = 0;
pos_t target_pod_pos = {-1, -1};

// Try to step, return 1 if success, 0 if blocked by another bot
void commit_step(pos_t newpos) {
    if (cell_is_free(newpos)) {
        if (pos != newpos) // At map entry we have pos == newpos
            map[pos.r][pos.c] -= B;

        map[newpos.r][newpos.c] |= B;
        pos = newpos;
    }
}

void enter_map() {
    commit_step(ENTRY_POS);
}

void get_task() {
    target_pod_id = dequeue();
    target_pod_pos = pod_position[target_pod_id];
}

void end_task() {
    pods[target_pod_id] = POD_FREE;
    target_pod_id = 0;
    target_pod_pos.r = -1;
    target_pod_pos.c = -1;
    tasks_completed++;
}

// Update given position one step in the only possible direction
void step(int cell, pos_t &amp;p) {
	if (cell &amp; N) p.r--;
	if (cell &amp; S) p.r++;
	if (cell &amp; E) p.c++;
	if (cell &amp; W) p.c--;
}

void step_towards_entry() {
    pos_t newpos = pos;
    int c = cell(pos);

    if (c &amp; X) {
        // We are at a cross, go N
		newpos.r--;
    } else {
        // Otherwise just follow the only possible dir
        step(c, newpos);
    }

    commit_step(newpos);
}

void step_towards_human() {
    pos_t newpos = pos;
    int c = cell(pos);

    if (c &amp; X) {
        // We are at a cross, go W
		newpos.c--;
    } else {
        // Otherwise just follow the only possible dir
        step(c, newpos);
    }

    commit_step(newpos);
}

void step_towards_pod() {
    pos_t newpos = pos;
    int c = cell(pos);

    if (pos.r == target_pod_pos.r + 1 &amp;&amp; pos.c == target_pod_pos.c) {
        // We are in the cell immediately S of the pod, go N
        newpos.r--;
    } else if (c &amp; X) {
        // We are at a cross
        if (pos.r == target_pod_pos.r + 1) {
            // We reached the pod row, go W
            newpos.c--;
        } else {
            // Otherwise go S
            newpos.r++;
        }
    } else {
        // Otherwise just follow the only possible dir
        step(c, newpos);
    }

    commit_step(newpos);
}
</declaration>
		<location id="id13" x="-348" y="-17">
		</location>
		<location id="id14" x="-255" y="-17">
			<name x="-323" y="-8">WAIT_FIRST_TASK</name>
		</location>
		<location id="id15" x="-136" y="153">
			<name x="-153" y="162">RESET</name>
			<label kind="invariant" x="-153" y="179">x &lt;= K</label>
		</location>
		<location id="id16" x="93" y="-17">
			<name x="0" y="-17">REACH_POD</name>
			<label kind="invariant" x="42" y="0">x &lt;= K</label>
		</location>
		<location id="id17" x="288" y="-17">
			<name x="306" y="-34">REACH_HUMAN</name>
			<label kind="invariant" x="306" y="-17">x &lt;= K</label>
		</location>
		<location id="id18" x="-136" y="-17">
			<name x="-161" y="-8">ENTER</name>
		</location>
		<location id="id19" x="289" y="153">
			<name x="212" y="162">RETURN_POD</name>
			<label kind="invariant" x="263" y="179">x &lt;= K</label>
		</location>
		<location id="id20" x="85" y="153">
			<name x="68" y="162">IDLE</name>
			<label kind="exponentialrate" x="25" y="179">BOT_IDLE_EXP_RATE</label>
		</location>
		<location id="id21" x="289" y="68">
		</location>
		<init ref="id13"/>
		<transition>
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="297" y="85">human_done?</label>
			<label kind="assignment" x="297" y="102">x = 0</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id19"/>
			<label kind="guard" x="340" y="127">pos != target_pod_pos
&amp;&amp; x &gt;= K</label>
			<label kind="assignment" x="340" y="162">step_towards_pod(), x = 0</label>
			<nail x="331" y="136"/>
			<nail x="331" y="170"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id15"/>
			<label kind="guard" x="-51" y="93">!queue_empty()</label>
			<label kind="synchronisation" x="-51" y="110">asap!</label>
			<label kind="assignment" x="-51" y="127">get_task(), x = 0</label>
			<nail x="16" y="153"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="guard" x="119" y="94">pos == target_pod_pos</label>
			<label kind="synchronisation" x="119" y="111">asap!</label>
			<label kind="assignment" x="119" y="128">end_task()</label>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id21"/>
			<label kind="guard" x="297" y="8">pos == HUMAN_POS</label>
			<label kind="synchronisation" x="297" y="25">delivery_ready!</label>
			<nail x="289" y="26"/>
			<nail x="289" y="42"/>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id16"/>
			<label kind="guard" x="-119" y="-76">cell_is_free(ENTRY_POS)</label>
			<label kind="synchronisation" x="-119" y="-59">asap!</label>
			<label kind="assignment" x="-119" y="-42">enter_map(), x = 0</label>
			<nail x="-17" y="-17"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id15"/>
			<label kind="guard" x="-331" y="128">pos != ENTRY_POS
&amp;&amp; x &gt;= K</label>
			<label kind="assignment" x="-357" y="162">step_towards_entry(), x = 0</label>
			<nail x="-187" y="161"/>
			<nail x="-187" y="136"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id17"/>
			<label kind="guard" x="272" y="-119">pos != HUMAN_POS
&amp;&amp; x &gt;= K</label>
			<label kind="assignment" x="271" y="-85">step_towards_human(), x = 0</label>
			<nail x="271" y="-59"/>
			<nail x="305" y="-59"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id17"/>
			<label kind="guard" x="119" y="-42">pos == target_pod_pos</label>
			<label kind="synchronisation" x="119" y="-17">asap!</label>
			<label kind="assignment" x="119" y="0">x = 0</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id16"/>
			<label kind="guard" x="76" y="-119">pos != target_pod_pos
&amp;&amp; x &gt;= K</label>
			<label kind="assignment" x="76" y="-85">step_towards_pod(), x = 0</label>
			<nail x="76" y="-59"/>
			<nail x="110" y="-59"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id16"/>
			<label kind="guard" x="-127" y="51">pos == ENTRY_POS</label>
			<label kind="synchronisation" x="-127" y="68">asap!</label>
			<label kind="assignment" x="-127" y="85">x = 0</label>
			<nail x="-136" y="42"/>
			<nail x="-102" y="42"/>
			<nail x="93" y="42"/>
			<nail x="93" y="17"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id18"/>
			<label kind="guard" x="-238" y="-76">!queue_empty()</label>
			<label kind="synchronisation" x="-238" y="-59">asap!</label>
			<label kind="assignment" x="-238" y="-42">get_task()</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id14"/>
			<label kind="synchronisation" x="-331" y="-42">init_done?</label>
		</transition>
	</template>
	<system>initializer = Initializer();
generator   = TaskGenerator(TASK_GEN_MEAN, TASK_GEN_VAR, N_PODS);
human       = Human(HUMAN_MEAN, HUMAN_VAR);

system initializer, generator, human, Bot;
</system>
	<queries>
		<query>
			<formula>E&lt;&gt; tasks_lost &gt; 0</formula>
			<comment></comment>
		</query>
		<query>
			<formula>Pr [&lt;=T] ( [] tasks_lost == 0 )</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
